{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/unit-testing-imposed-with-a-code-coverage-target-do-not-worry","result":{"data":{"markdownRemark":{"excerpt":"This happened in one of my previous company. We were working on a C# and .NET project. We got a request, all of a sudden, to start unitâ€¦","html":"<p>This happened in one of my previous company. We were working on a C# and .NET project. We got a request, all of a sudden, to start unit tests implementation with atleast 50% of code coverage.</p>\n<p>In this project, units tests were not implemented previously due to some technical issues. It seems that the product was architected not keeping unit tests in mind.</p>\n<p>The UI of the current project was on Winforms and most of the business logic was in the code behind of the UI. Again why? People must have chosen to do so because the UI components were small and were doing a very specific task. Seems like the developer did not expect this to change anytime soon.</p>\n<p>The project that I worked on was based on a plugin architecture. Our plugin connected to other third party services, fetched data, and displayed result. It is as simple as that.</p>\n<p>So, we started implementing the unit tests. But, we did not know where to implement unit tests.</p>\n<p>Here is how we started</p>\n<p>By definition unit tests are implemented on the unit of work. Like I said previously, our plugin connected to a third party service. Lets me make this easier for you by taking an example. Assume that our plugin is hitting the Google API to find properties that are for sale in a locality (I dont think Google currently gives any such service).</p>\n<p>Now, you have a requirement to filter it by a certain criteria say by price. Applying filter is a unit of work with its own logical operation. So, we have an oppertunity to write unit tests.</p>\n<p>Generally, we write this logic in the code behind. By doing this we make our life difficult. Targetting, unit tests for logic written in code behind is not a good practice.</p>\n<p>So, lets move this filter logic to seperate class file in a new project. By doing this we can gracefully test the logic.</p>\n<p>Now, how do we call this method in UI. Here comes MVP (Model-View-Presenter) pattern to the rescue. Your presenter will make a call the newly created Filter class file and get the filtered list.</p>\n<p>Here is the implementation part. All is not good and rosy when you are working on unit tests for the first time. Especially in legacy project that has technology stack like Winforms.</p>\n<h3 id=\"Clear-boundary-between-unit-and-integration-tests\" style=\"position:relative;\"><a href=\"#Clear-boundary-between-unit-and-integration-tests\" aria-label=\"Clear boundary between unit and integration tests permalink\" class=\"gatsby-remark-autolink before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Clear boundary between unit and integration tests</h3>\n<p>There is a natural tendency to make the Google API call while writing unit tests. We should not be making any call to the APIs while we are writing Unit test cases. Why?</p>\n<ul>\n<li>we are testing the logic and not API here</li>\n<li>API testing is handled by another set of tests called the Integration tests</li>\n<li>takes a lot of time to complete unit tests</li>\n</ul>\n<p>If a situation arises the demands the need to call an API method. Then we need to mock the API call using mocking frameworks.</p>\n<h3 id=\"Framework-had-some-features-that-was-not-easy-to-mock\" style=\"position:relative;\"><a href=\"#Framework-had-some-features-that-was-not-easy-to-mock\" aria-label=\"Framework had some features that was not easy to mock permalink\" class=\"gatsby-remark-autolink before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Framework had some features that was not easy to mock</h3>\n<p>Yes the framework was a little old. Because of this some features could not be mocked. Code coverage got reduced. These are few things that are beyond ones control. So, do not worry about this as of now.</p>\n<h3 id=\"Code-coverage\" style=\"position:relative;\"><a href=\"#Code-coverage\" aria-label=\"Code coverage permalink\" class=\"gatsby-remark-autolink before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code coverage</h3>\n<p>Generally, unit test are measured in terms of code coverage. However, I feel it is not the only metrics. Why? We can cover the entire UI code with unit tests.</p>\n<p>So, the thumb rule is to</p>\n<ul>\n<li>segregate logical units to different classes and group them into projects</li>\n<li>then make sure you have a close to 100% coverage on the code for these logically grouped projects</li>\n<li>also, get a peer code review where the reviewer would do a boundary value analysis</li>\n</ul>\n<h3 id=\"Presenting-the-unit-test-case-coverage-with-stakeholder\" style=\"position:relative;\"><a href=\"#Presenting-the-unit-test-case-coverage-with-stakeholder\" aria-label=\"Presenting the unit test case coverage with stakeholder permalink\" class=\"gatsby-remark-autolink before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Presenting the unit test case coverage with stakeholder</h3>\n<p>Generally, the code coverage is measured in the CI pipeline. If the unit test case coverage is taken for all the projects (including the UI), then coverage would dip. So, it makes sense to check coverage only for those projects where the code is performing certain logic. In our case the project that performs filtering is the right candidate for code coverage.</p>\n<p>Visual studio gives us way to include only certain projects in the code coverage report and exclude other. This can be configured using the runsettings file. <a href=\"https://learn.microsoft.com/en-us/visualstudio/test/customizing-code-coverage-analysis?view=vs-2022#include-or-exclude-assemblies-and-members\">Here</a> is a microsoft link that give a quick illustration.</p>\n<p>Make sure you discuss will the stakeholder before including or excluding your projects in the code coverage report.</p>\n<h3 id=\"Estimation-the-tasks-that-includes-implementation-of-unit-test-cases\" style=\"position:relative;\"><a href=\"#Estimation-the-tasks-that-includes-implementation-of-unit-test-cases\" aria-label=\"Estimation the tasks that includes implementation of unit test cases permalink\" class=\"gatsby-remark-autolink before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Estimation the tasks that includes implementation of unit test cases</h3>\n<p>Lets say you have to consume a similar search service from Google and you quote 9-12 hours in your estimations. This is because previously you had implemented a similar service and had taken 9-12 hours. Now, with unit testing coming in picture. You will have a natural tendency to add 4 - 5 hours extra for unit test case projects.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>Task</strong></th>\n<th align=\"center\"><strong>Estimates</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">Invoking the property search from plugin</td>\n<td align=\"center\">12 hrs</td>\n</tr>\n<tr>\n<td align=\"center\">Adding unit tests</td>\n<td align=\"center\">4 hrs</td>\n</tr>\n</tbody>\n</table>\n<p>The trouble arises when you start implementing unit test cases. It is easy to write unit test cases but difficult to write code that is unit testable. So, generally when you start writing unit test cases for the first time it is advised at a buffer of 80-100%. So, your estimation now changes to</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>Task</strong></th>\n<th align=\"center\"><strong>Estimates</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">Invoking the property search from plugin</td>\n<td align=\"center\">12 hrs</td>\n</tr>\n<tr>\n<td align=\"center\">Adding unit tests</td>\n<td align=\"center\">8 hrs</td>\n</tr>\n</tbody>\n</table>\n<p>100% buffer is too high. None of the stakeholders would approve this. But, remember, this estimation is only for the first time when the team attempts add unit test cases. This would also apply to any new team member in the project.</p>\n<p>However, as an when the team member gets aquainted to the project. The member would take very little time to write unit testable code and would take less than 4 hrs to write unit test case in the third or fourth interation.</p>\n<h3 id=\"Save-time-and-money\" style=\"position:relative;\"><a href=\"#Save-time-and-money\" aria-label=\"Save time and money permalink\" class=\"gatsby-remark-autolink before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Save time and money</h3>\n<p>If you have reached reading till here then I am sure that you are really interested in implementing unit test and code coverage in the right way.</p>\n<p>So, here are some bonus features that unit tests will provide you\nBy writing unit tests, we as a developer, will be more confident in making changes. Imagine if there is a small modification in the requirements. You make that change. But, you are not sure if this change breaks any existing functionality. So, you need not retest every feature manually. Just run the unit test cases and check if there are any failed test cases. If not then you are good to go.</p>","timeToRead":5,"id":"cceeac61-4f44-5b53-b2ea-9220f787d1fe","frontmatter":{"date":"June 01, 2020","title":"Unit testing imposed with a code coverage target! Do not worry!"}}},"pageContext":{"slug":"/blog/unit-testing-imposed-with-a-code-coverage-target-do-not-worry"}},"staticQueryHashes":["1033876704","3435786681","550521386"]}